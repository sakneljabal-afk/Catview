<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø¯ÙØ¹ ÙˆØ§Ù„ÙÙ‚Ø§Ø¹Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        /* ğŸ¨ CSS Ø§Ù„ØªØµÙ…ÙŠÙ… */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            direction: rtl; 
            background-color: #add8e6; 
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø³Ø¤Ø§Ù„ */
        #questionBox {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000; 
            background-color: rgba(0, 0, 0, 0.8); 
            color: white;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
        }

        #questionBox h3 {
            margin: 0;
            font-size: clamp(1.2em, 3vw, 1.5em); 
        }

        /* ÙÙŠØ¯Ø¨Ø§Ùƒ Ø®Ø·Ø£ (Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø­Ù…Ø±) */
        #wrongFeedback {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(255, 0, 0, 0); 
            z-index: 999; 
            pointer-events: none;
            transition: background-color 0.1s; 
        }
        
        /* Ù…Ø¤Ø´Ø± Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ø¨ØµØ±ÙŠ (â›”) */
        #errorIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10em; 
            color: white;
            z-index: 1001; 
            opacity: 0; 
            pointer-events: none;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <div id="wrongFeedback"></div>
    <div id="errorIndicator">â›”</div>
    <div id="questionBox"></div>
    <div id="game-container"></div>

<script>
    // ğŸ’¾ Ù…ØµÙÙˆÙØ© Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
    const QUESTIONS = [
        {question:"Ù…Ø§ Ù‡Ùˆ Ø§Ù„ÙƒÙˆÙƒØ¨ Ø§Ù„Ø°ÙŠ ÙŠØ³Ù…Ù‰ 'Ø§Ù„ÙƒÙˆÙƒØ¨ Ø§Ù„Ø£Ø­Ù…Ø±'ØŸ", options:["Ø§Ù„Ø²Ù‡Ø±Ø©","Ø§Ù„Ù…Ø±ÙŠØ®","Ø§Ù„Ù…Ø´ØªØ±ÙŠ"], correctAnswer:"Ø§Ù„Ù…Ø±ÙŠØ®"},
        {question:"ÙƒÙ… Ø¹Ø¯Ø¯ Ø£Ø±Ø¬Ù„ Ø§Ù„Ù‚Ø·Ø·ØŸ", options:["Ø§Ø«Ù†ÙŠÙ†","Ø£Ø±Ø¨Ø¹Ø©","Ø³ØªØ©"], correctAnswer:"Ø£Ø±Ø¨Ø¹Ø©"},
        {question:"Ù…Ø§ Ù‡Ùˆ Ø£ÙƒØ¨Ø± Ù…Ø­ÙŠØ· ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", options:["Ø§Ù„Ø£Ø·Ù„Ø³ÙŠ","Ø§Ù„Ù‡Ù†Ø¯ÙŠ","Ø§Ù„Ù‡Ø§Ø¯Ø¦"], correctAnswer:"Ø§Ù„Ù‡Ø§Ø¯Ø¦"},
        {question:"Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø«Ù„Ø§Ø«Ø© Ø£Ø¶Ù„Ø§Ø¹ØŸ", options:["Ø§Ù„Ù…Ø±Ø¨Ø¹","Ø§Ù„Ù…Ø«Ù„Ø«","Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©"], correctAnswer:"Ø§Ù„Ù…Ø«Ù„Ø«"}
    ];

    // ğŸ–¼ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
    const config = {
        type: Phaser.AUTO,
        width: 800, 
        height: 1200, 
        parent: 'game-container',
        scale: { 
            mode: Phaser.Scale.FIT, 
            autoCenter: Phaser.Scale.CENTER_BOTH,
            parent: 'game-container',
            width: 800,
            height: 1200
        },
        physics: { 
            default:'arcade', 
            arcade:{ 
                gravity:{y:0}, 
                // ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ù‡Ø°Ø§ Ø¥Ù„Ù‰ true Ù„Ø±Ø¤ÙŠØ© Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„ØªØµØ§Ø¯Ù… ÙˆØªØµØ­ÙŠØ­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
                debug: false 
            } 
        },
        scene: { preload, create, update }
    };

    let game = new Phaser.Game(config);

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø¹Ø§Ù…Ø©
    let cannon, projectileGroup, bubblesGroup;
    let questionBox, wrongFeedbackDiv, errorIndicator;
    let correctSound, wrongSound;
    let currentQuestionIndex = 0;
    let questionToRepeat = null; 
    let originalQuestionIndexBeforeError = 0; 

    const BUBBLE_TYPES = ['bubble1', 'bubble2', 'bubble3'];
    
    // â¬‡ï¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø«Ø§Ù†ÙŠ: ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª
    const BUBBLE_SCALE = 0.15; 
    
    let FIRE_DELAY = 200; 
    let lastFired = 0;

    function preload() {
        this.load.image('cannon', 'assets/cannon.png');
        this.load.image('shoot', 'assets/shoot.png');
        this.load.image('bubble1', 'assets/bubble1.png');
        this.load.image('bubble2', 'assets/bubble2.png');
        this.load.image('bubble3', 'assets/bubble3.png');
        
        this.load.audio('correct','assets/correct.mp3'); 
        this.load.audio('wrong','assets/wrong.mp3');
        this.load.audio('fire','assets/fire.mp3'); 
    }

    function create() {
        const { width, height } = this.scale;
        
        // 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ø¹Ù†Ø§ØµØ± HTML
        questionBox = document.getElementById('questionBox');
        wrongFeedbackDiv = document.getElementById('wrongFeedback');
        errorIndicator = document.getElementById('errorIndicator');

        // 2. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ØµÙˆØ§Øª
        correctSound = this.sound.add('correct');
        wrongSound = this.sound.add('wrong');
        this.fireSound = this.sound.add('fire');
        
        this.input.once('pointerdown', () => {
            if (this.sound.context.state !== 'running') {
                this.sound.context.resume();
            }
        });

        // 3. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¯ÙØ¹ (Cannon)
        // â¬‡ï¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„: ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù…Ø¯ÙØ¹ (0.4) ÙˆÙˆØ¶Ø¹Ù‡ ÙÙŠ Ù…ÙƒØ§Ù† Ù…Ù†Ø§Ø³Ø¨
        cannon = this.add.sprite(width / 2, height * 0.90, 'cannon').setScale(0.4); 
        cannon.setDepth(10);
        
        // 4. Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ (Physics Groups)
        projectileGroup = this.physics.add.group({
            defaultKey: 'shoot',
            maxSize: 10,
            runChildUpdate: true
        });

        bubblesGroup = this.physics.add.group({
            key: BUBBLE_TYPES,
            immovable: false,
            runChildUpdate: true
        });

        // 5. ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
        this.physics.add.overlap(projectileGroup, bubblesGroup, hitBubble, null, this);

        // 6. Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
        this.input.on('pointermove', pointer => {
            cannon.x = Phaser.Math.Clamp(pointer.x, width * 0.1, width * 0.9);
        });

        // 7. Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù‚Ø°ÙŠÙØ©
        this.input.on('pointerdown', pointer => {
            if(this.input.enabled) { 
                fireProjectile(this);
            }
        });

        // 8. Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        showQuestion(currentQuestionIndex);
    }

    function update(time, delta) {}

    // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…Ø¯ÙØ¹ ÙˆØ§Ù„Ù‚Ø°Ø§Ø¦Ù ---

    function fireProjectile(scene) {
        if (scene.time.now > lastFired + FIRE_DELAY) {
            this.fireSound.play();
            
            const projectile = projectileGroup.get(cannon.x, cannon.y - 50);
            
            if (projectile) {
                // â¬‡ï¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø«Ø§Ù„Ø« (Ø§Ù„Ù‡Ø§Ù…): ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·Ù‡
                projectile.enableBody(true, cannon.x, cannon.y - 50, true, true);
                
                // ØªØµØºÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù‚Ø°ÙŠÙØ© Ù„ØªÙ†Ø§Ø³Ø¨ Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø©
                projectile.setScale(0.15); 
                
                // Ø¶Ø¨Ø· Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµØ§Ø¯Ù… Ù„Ù„Ù‚Ø°ÙŠÙØ©
                projectile.body.setCircle(projectile.width * 0.5);

                projectile.setVelocityY(-1000); 
                
                lastFired = scene.time.now; 

                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø°ÙŠÙØ© Ø¹Ù†Ø¯ Ø®Ø±ÙˆØ¬Ù‡Ø§
                scene.time.delayedCall(1500, () => {
                    if (projectile.active) {
                        projectile.setActive(false).setVisible(false);
                        projectile.disableBody(true, true); // ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø®ÙØ§Ø¡
                    }
                });
            }
        }
    }

    function hitBubble(projectile, bubble) {
        // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù‚Ø°ÙŠÙØ© ÙÙˆØ±Ø§Ù‹ ÙˆØªØ¹Ø·ÙŠÙ„ Ø¬Ø³Ù…Ù‡Ø§ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ
        projectile.setActive(false).setVisible(false);
        projectile.disableBody(true, true);

        const bubbleData = bubble.getData('data');

        if (!bubbleData) {
            bubble.destroy();
            return;
        }

        checkAnswer(bubble, bubbleData.answer);
    }

    // --- Ù…Ù†Ø·Ù‚ Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¦Ù„Ø© ---

    function createBubbles(scene, questionData) {
        bubblesGroup.children.each((bubble) => {
            if (bubble && bubble.active) {
                bubble.destroy(); // Ø§Ø³ØªØ®Ø¯Ø§Ù… destroy Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
            }
        });
        bubblesGroup.clear(true, true); 

        const { width, height } = scene.scale;
        const options = questionData.options;

        const startY = height * 0.15;
        const endY = height * 0.55;

        Phaser.Utils.Array.Shuffle(options); 
        
        options.forEach((opt, index) => {
            const bubbleType = BUBBLE_TYPES[index % BUBBLE_TYPES.length];
            
            const x = Phaser.Math.Between(width * 0.1, width * 0.9);
            const y = Phaser.Math.Between(startY, endY);
            
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
            const bubble = bubblesGroup.create(x, y, bubbleType).setScale(BUBBLE_SCALE);
            
            // Ø¶Ø¨Ø· Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµØ§Ø¯Ù… Ù„Ù„ÙÙ‚Ø§Ø¹Ø©
            bubble.body.setCircle(bubble.width * 0.45); 

            bubble.setData('data', {
                answer: opt,
                index: index + 1
            });

            // ØªØµØºÙŠØ± Ø§Ù„Ø®Ø· Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„ÙÙ‚Ø§Ø¹Ø© Ø§Ù„ØµØºÙŠØ±Ø©
            const answerText = scene.add.text(x, y, opt, { 
                fontFamily: 'Arial',
                fontSize: '16px', // â¬‡ï¸ Ø®Ø· Ø£ØµØºØ±
                color: '#000',
                backgroundColor: '#ffffffcc', 
                padding: { x: 5, y: 3 },
                align: 'center',
                wordWrap: { width: bubble.displayWidth, useSoftWrap: true }
            }).setOrigin(0.5);

            bubble.setDepth(2);
            answerText.setDepth(3);
            
            bubble.on('destroy', () => { answerText.destroy(); });
            bubble.on('postupdate', () => { 
                answerText.x = bubble.x;
                answerText.y = bubble.y; 
            });
            
            const speed = 150; 
            bubble.setVelocity(
                Phaser.Math.Between(-speed, speed),
                Phaser.Math.Between(-speed, speed)
            );
            
            bubble.setBounce(1);
            bubble.setCollideWorldBounds(true);
        });
        
    }

    // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¤Ø§Ù„ (Ù„Ù… ØªØªØºÙŠØ±)
    function showQuestion(index){
        const isReviewing = questionToRepeat !== null;
        const q = isReviewing ? questionToRepeat : QUESTIONS[index];
        const scene = game.scene.getScene('default');

        if(!q){
            questionBox.innerHTML='<h3>Ø£Ø­Ø³Ù†Øª! Ù„Ù‚Ø¯ Ø£Ù†Ù‡ÙŠØª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­!</h3>';
            bubblesGroup.clear(true, true); 
            return;
        }

        questionBox.innerHTML = `<h3>Ø§Ù„Ø³Ø¤Ø§Ù„ ${isReviewing ? "(Ù…Ø±Ø§Ø¬Ø¹Ø©)" : index + 1}: ${q.question}</h3>`;

        createBubbles(scene, q);
    }

    // Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Ù„Ù… ØªØªØºÙŠØ±)
    function checkAnswer(bubble, selectedAnswer){
        const scene = game.scene.getScene('default');
        
        const isReviewing = questionToRepeat !== null;
        const currentQ = isReviewing ? questionToRepeat : QUESTIONS[currentQuestionIndex];

        scene.input.enabled = false;

        if(selectedAnswer === currentQ.correctAnswer){
            correctSound.play();
            
            bubble.destroy(); 

            scene.time.delayedCall(500, ()=>{
                scene.input.enabled = true; 
                
                let nextIndex = currentQuestionIndex + 1; 
                
                if(isReviewing){
                    if (nextIndex === originalQuestionIndexBeforeError) {
                        questionToRepeat = null; 
                        currentQuestionIndex = nextIndex; 
                        showQuestion(currentQuestionIndex);
                    } else if (nextIndex < QUESTIONS.length) {
                        currentQuestionIndex = nextIndex;
                        showQuestion(currentQuestionIndex);
                    } else {
                        showQuestion(QUESTIONS.length);
                    }
                    
                } else {
                    if(nextIndex < QUESTIONS.length){
                        currentQuestionIndex = nextIndex;
                        showQuestion(currentQuestionIndex);
                    } else { 
                        showQuestion(nextIndex); 
                    }
                }
            });

        } else {
            wrongSound.play();
            
            wrongFeedbackDiv.style.backgroundColor='rgba(255,0,0,0.5)';
            errorIndicator.style.opacity = 1;

            scene.time.delayedCall(400, ()=>{
                wrongFeedbackDiv.style.backgroundColor='rgba(255,0,0,0)';
                errorIndicator.style.opacity = 0;
            });
            
            if(currentQuestionIndex > 0){
                
                if(!isReviewing) {
                   questionToRepeat = currentQ;
                   originalQuestionIndexBeforeError = currentQuestionIndex + 1; 
                }

                let prevIndex = currentQuestionIndex - 1;
                currentQuestionIndex = prevIndex;
                
                scene.time.delayedCall(1500, ()=>{
                    scene.input.enabled = true; 
                    showQuestion(currentQuestionIndex); 
                });
                
            } else {
                scene.time.delayedCall(500, ()=>{
                    scene.input.enabled = true; 
                    showQuestion(currentQuestionIndex); 
                });
            }
        }
    }
</script>
</body>
</html>
