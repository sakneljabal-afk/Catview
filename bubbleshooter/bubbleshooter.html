<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø¯ÙØ¹ ÙˆØ§Ù„ÙÙ‚Ø§Ø¹Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        /* ğŸ¨ CSS Ø§Ù„ØªØµÙ…ÙŠÙ… */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            direction: rtl; 
            background-color: #add8e6; 
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø³Ø¤Ø§Ù„ */
        #questionBox {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000; 
            background-color: rgba(0, 0, 0, 0.8); 
            color: white;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
        }

        #questionBox h3 {
            margin: 0;
            font-size: clamp(1.2em, 3vw, 1.5em); 
        }

        /* ÙÙŠØ¯Ø¨Ø§Ùƒ Ø®Ø·Ø£ (Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø­Ù…Ø±) */
        #wrongFeedback {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(255, 0, 0, 0); 
            z-index: 999; 
            pointer-events: none;
            transition: background-color 0.1s; 
        }
        
        /* Ù…Ø¤Ø´Ø± Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ø¨ØµØ±ÙŠ (â›”) */
        #errorIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10em; 
            color: white;
            z-index: 1001; 
            opacity: 0; 
            pointer-events: none;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <div id="wrongFeedback"></div>
    <div id="errorIndicator">â›”</div>
    <div id="questionBox"></div>
    <div id="game-container"></div>

<script>
    // ğŸ’¾ Ù…ØµÙÙˆÙØ© Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
    const QUESTIONS = [
        {question:"Ù…Ø§ Ù‡Ùˆ Ø§Ù„ÙƒÙˆÙƒØ¨ Ø§Ù„Ø°ÙŠ ÙŠØ³Ù…Ù‰ 'Ø§Ù„ÙƒÙˆÙƒØ¨ Ø§Ù„Ø£Ø­Ù…Ø±'ØŸ", options:["Ø§Ù„Ø²Ù‡Ø±Ø©","Ø§Ù„Ù…Ø±ÙŠØ®","Ø§Ù„Ù…Ø´ØªØ±ÙŠ"], correctAnswer:"Ø§Ù„Ù…Ø±ÙŠØ®"},
        {question:"ÙƒÙ… Ø¹Ø¯Ø¯ Ø£Ø±Ø¬Ù„ Ø§Ù„Ù‚Ø·Ø·ØŸ", options:["Ø§Ø«Ù†ÙŠÙ†","Ø£Ø±Ø¨Ø¹Ø©","Ø³ØªØ©"], correctAnswer:"Ø£Ø±Ø¨Ø¹Ø©"},
        {question:"Ù…Ø§ Ù‡Ùˆ Ø£ÙƒØ¨Ø± Ù…Ø­ÙŠØ· ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", options:["Ø§Ù„Ø£Ø·Ù„Ø³ÙŠ","Ø§Ù„Ù‡Ù†Ø¯ÙŠ","Ø§Ù„Ù‡Ø§Ø¯Ø¦"], correctAnswer:"Ø§Ù„Ù‡Ø§Ø¯Ø¦"},
        {question:"Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø«Ù„Ø§Ø«Ø© Ø£Ø¶Ù„Ø§Ø¹ØŸ", options:["Ø§Ù„Ù…Ø±Ø¨Ø¹","Ø§Ù„Ù…Ø«Ù„Ø«","Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©"], correctAnswer:"Ø§Ù„Ù…Ø«Ù„Ø«"}
    ];

    // ğŸ–¼ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
    const config = {
        type: Phaser.AUTO,
        width: 800, 
        height: 1200, 
        parent: 'game-container',
        scale: { 
            mode: Phaser.Scale.FIT, 
            autoCenter: Phaser.Scale.CENTER_BOTH,
            parent: 'game-container',
            width: 800,
            height: 1200
        },
        physics: { 
            default:'arcade', 
            arcade:{ 
                gravity:{y:0}, 
                // ÙˆØ¶Ø¹ Ù‡Ø°Ø§ Ø¹Ù„Ù‰ true Ù‚Ø¯ ÙŠØ³Ø§Ø¹Ø¯ ÙÙŠ Ø±Ø¤ÙŠØ© Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø£Ø¬Ø³Ø§Ù… Ù„Ù„ØªØµØ­ÙŠØ­
                debug:false 
            } 
        },
        scene: { preload, create, update }
    };

    let game = new Phaser.Game(config);

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø¹Ø§Ù…Ø©
    let cannon, projectileGroup, bubblesGroup;
    let questionBox, wrongFeedbackDiv, errorIndicator;
    let correctSound, wrongSound;
    let currentQuestionIndex = 0;
    let questionToRepeat = null; 
    let originalQuestionIndexBeforeError = 0; 

    const BUBBLE_TYPES = ['bubble1', 'bubble2', 'bubble3'];
    // ğŸ¯ ØªÙ… ØªØ®ÙÙŠØ¶ Ø­Ø¬Ù… Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
    const BUBBLE_SCALE = 0.2; 
    let FIRE_DELAY = 200; // ğŸ¯ ØªÙ… ØªØ®ÙÙŠØ¶ ØªØ£Ø®ÙŠØ± Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚
    let lastFired = 0;

    function preload() {
        // âœ… Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø± 'assets/'
        this.load.image('cannon', 'assets/cannon.png');
        this.load.image('shoot', 'assets/shoot.png');
        this.load.image('bubble1', 'assets/bubble1.png');
        this.load.image('bubble2', 'assets/bubble2.png');
        this.load.image('bubble3', 'assets/bubble3.png');
        
        this.load.audio('correct','assets/correct.mp3'); 
        this.load.audio('wrong','assets/wrong.mp3');
        this.load.audio('fire','assets/fire.mp3'); 
    }

    function create() {
        const { width, height } = this.scale;
        
        // 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ø¹Ù†Ø§ØµØ± HTML
        questionBox = document.getElementById('questionBox');
        wrongFeedbackDiv = document.getElementById('wrongFeedback');
        errorIndicator = document.getElementById('errorIndicator');

        // 2. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ØµÙˆØ§Øª (ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙ… ØªØ´ØºÙŠÙ„Ù‡Ø§ Ù‡Ù†Ø§ Ù„ØªØ¬Ø§ÙˆØ² Ù‚ÙŠÙˆØ¯ Ø§Ù„Ù…ØªØµÙØ­)
        correctSound = this.sound.add('correct');
        wrongSound = this.sound.add('wrong');
        this.fireSound = this.sound.add('fire');
        // ğŸ’¡ ØªÙ„Ù…ÙŠØ­: ØªØ´ØºÙŠÙ„ ØµÙˆØª ØµØ§Ù…Øª Ø¹Ù†Ø¯ Ø£ÙˆÙ„ Ù†Ù‚Ø±Ø©/Ù„Ù…Ø³Ø© ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØ­Ù„ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø£ØµÙˆØ§Øª
        this.input.once('pointerdown', () => {
            if (this.sound.context.state !== 'running') {
                this.sound.context.resume();
            }
        });

        // 3. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¯ÙØ¹ (Cannon)
        cannon = this.add.sprite(width / 2, height * 0.95, 'cannon').setScale(0.8); 
        cannon.setDepth(10);
        
        // 4. Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ (Physics Groups)
        projectileGroup = this.physics.add.group({
            defaultKey: 'shoot',
            maxSize: 10,
            runChildUpdate: true,
            // ğŸ’¡ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù„Ù„Ø¬Ø³Ù…
            createCallback: function (projectile) {
                // Ø¶Ø¨Ø· Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ØªÙŠ ØªØ¶Ù…Ù† Ø£Ù† Ø§Ù„Ù‚Ø°ÙŠÙØ© Ù…Ø±Ø¦ÙŠØ© ÙˆÙ„Ù‡Ø§ Ø¯Ø§Ø¦Ø±Ø© ØªØµØ§Ø¯Ù…
                projectile.body.setCircle(projectile.width * 0.5); // Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµØ§Ø¯Ù… Ù†ØµÙ Ù‚Ø·Ø±Ù‡Ø§ Ù†ØµÙ Ø§Ù„Ø¹Ø±Ø¶
                projectile.body.allowGravity = false;
            }
        });

        bubblesGroup = this.physics.add.group({
            key: BUBBLE_TYPES,
            immovable: false,
            runChildUpdate: true
        });

        // 5. ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
        this.physics.add.overlap(projectileGroup, bubblesGroup, hitBubble, null, this);

        // 6. Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (Ø§Ù„Ù…Ø¯ÙØ¹ ÙŠØªØ¨Ø¹ Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø¤Ø´Ø±/Ø§Ù„Ù„Ù…Ø³)
        this.input.on('pointermove', pointer => {
            cannon.x = Phaser.Math.Clamp(pointer.x, width * 0.1, width * 0.9);
        });

        // 7. Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù‚Ø°ÙŠÙØ© Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø±/Ø§Ù„Ù„Ù…Ø³
        this.input.on('pointerdown', pointer => {
            if(this.input.enabled) { 
                fireProjectile(this);
            }
        });

        // 8. Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        showQuestion(currentQuestionIndex);
    }

    function update(time, delta) {}

    // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…Ø¯ÙØ¹ ÙˆØ§Ù„Ù‚Ø°Ø§Ø¦Ù ---

    function fireProjectile(scene) {
        if (scene.time.now > lastFired + FIRE_DELAY) {
            // ğŸ’¡ Ø³ÙŠØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª Ù‡Ù†Ø§
            this.fireSound.play();
            // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… .get() Ù…Ø¹ ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù„Ø¶Ù…Ø§Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø¬Ø³Ø§Ù…
            const projectile = projectileGroup.get(cannon.x, cannon.y - cannon.displayHeight/2);
            
            if (projectile) {
                // ğŸ¯ ØªÙ‚Ù„ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù‚Ø°ÙŠÙØ© Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ±Ù‡Ø§
                projectile.setActive(true).setVisible(true).setScale(0.25); 
                // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµØ§Ø¯Ù… Ø¨Ø¹Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù€ scale
                projectile.body.setCircle(projectile.width / 2);

                projectile.setVelocityY(-1000); // Ø³Ø±Ø¹Ø© Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ù„Ù„Ø£Ø¹Ù„Ù‰
                
                // ğŸ’¡ Ø§Ù„Ù…Ø¯ÙØ¹ Ù„Ø§ ÙŠØ·Ù„Ù‚ Ø¥Ù„Ø§ Ø¨Ø¹Ø¯ Ù…Ø±ÙˆØ± Ù‡Ø°Ø§ Ø§Ù„ÙˆÙ‚Øª
                lastFired = scene.time.now; 

                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø°ÙŠÙØ© Ø¹Ù†Ø¯ Ø®Ø±ÙˆØ¬Ù‡Ø§ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø© (Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„ØªØ£Ø®ÙŠØ±)
                scene.time.delayedCall(1500, () => {
                    projectile.setActive(false).setVisible(false);
                    projectileGroup.killAndHide(projectile); // Ø¥Ø¹Ø§Ø¯ØªÙ‡Ø§ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                });
            }
        }
    }

    function hitBubble(projectile, bubble) {
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø°ÙŠÙØ©
        projectile.setActive(false).setVisible(false);
        projectileGroup.killAndHide(projectile);

        const bubbleData = bubble.getData('data');

        if (!bubbleData) {
            bubble.emit('destroy'); 
            bubble.destroy();
            return;
        }

        checkAnswer(bubble, bubbleData.answer);
    }

    // --- Ù…Ù†Ø·Ù‚ Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø£Ø³Ø¦Ù„Ø© ---

    function createBubbles(scene, questionData) {
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ÙˆÙ†ØµÙˆØµÙ‡Ø§
        bubblesGroup.children.each((bubble) => {
            if (bubble && bubble.active) {
                bubble.emit('destroy'); 
                bubble.destroy();
            }
        });
        bubblesGroup.clear(true, true); 

        const { width, height } = scene.scale;
        const options = questionData.options;

        const startY = height * 0.1;
        const endY = height * 0.6; // ğŸ¯ Ø²ÙŠØ§Ø¯Ø© Ù…Ù†Ø·Ù‚Ø© Ø­Ø±ÙƒØ© Ø§Ù„ÙÙ‚Ø§Ø¹Ø§Øª

        Phaser.Utils.Array.Shuffle(options); 
        
        options.forEach((opt, index) => {
            const bubbleType = BUBBLE_TYPES[index % BUBBLE_TYPES.length];
            
            const x = Phaser.Math.Between(width * 0.1, width * 0.9);
            const y = Phaser.Math.Between(startY, endY);
            
            const bubble = bubblesGroup.create(x, y, bubbleType).setScale(BUBBLE_SCALE);
            // ğŸ¯ Ø¶Ø¨Ø· Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµØ§Ø¯Ù… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø¬Ù… Ø§Ù„ÙÙ‚Ø§Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯
            bubble.body.setCircle(bubble.width / 2); 

            bubble.setData('data', {
                answer: opt,
                index: index + 1
            });

            const answerText = scene.add.text(x, y, opt, { 
                fontFamily: 'Arial',
                fontSize: 20,
                color: '#000',
                backgroundColor: '#ffffffcc', 
                padding: { x: 8, y: 5 },
                wordWrap: { width: bubble.displayWidth - 20, useSoftWrap: true }
            }).setOrigin(0.5);

            bubble.setDepth(2);
            answerText.setDepth(3);
            
            bubble.on('destroy', () => { answerText.destroy(); });
            bubble.on('postupdate', () => { 
                answerText.x = bubble.x;
                answerText.y = bubble.y; 
            });
            
            // ğŸ¯ Ø³Ø±Ø¹Ø© Ù…ØªÙˆØ³Ø·Ø©
            const speed = 150; 
            bubble.setVelocity(
                Phaser.Math.Between(-speed, speed),
                Phaser.Math.Between(-speed, speed)
            );
            
            // ğŸ¯ Ø¶Ø¨Ø· Ø§Ù„Ø§Ø±ØªØ¯Ø§Ø¯ ÙˆØ§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
            bubble.setBounce(1);
            bubble.setCollideWorldBounds(true);

            // âŒ ØªÙ… Ø­Ø°Ù setBoundsRectangle Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø­Ø±ÙƒØ© Ø£ÙˆØ³Ø¹
        });
        
    }

    // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¤Ø§Ù„ (Ù„Ù… ÙŠØªÙ… ØªØºÙŠÙŠØ±Ù‡Ø§)
    function showQuestion(index){
        const isReviewing = questionToRepeat !== null;
        const q = isReviewing ? questionToRepeat : QUESTIONS[index];
        const scene = game.scene.getScene('default');

        if(!q){
            questionBox.innerHTML='<h3>Ø£Ø­Ø³Ù†Øª! Ù„Ù‚Ø¯ Ø£Ù†Ù‡ÙŠØª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­!</h3>';
            bubblesGroup.clear(true, true); 
            return;
        }

        questionBox.innerHTML = `<h3>Ø§Ù„Ø³Ø¤Ø§Ù„ ${isReviewing ? "(Ù…Ø±Ø§Ø¬Ø¹Ø©)" : index + 1}: ${q.question}</h3>`;

        createBubbles(scene, q);
    }

    // Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Ù„Ù… ÙŠØªÙ… ØªØºÙŠÙŠØ±Ù‡Ø§)
    function checkAnswer(bubble, selectedAnswer){
        const scene = game.scene.getScene('default');
        
        const isReviewing = questionToRepeat !== null;
        const currentQ = isReviewing ? questionToRepeat : QUESTIONS[currentQuestionIndex];

        scene.input.enabled = false;

        if(selectedAnswer === currentQ.correctAnswer){
            correctSound.play();
            
            bubble.emit('destroy'); 
            bubble.destroy(); 

            scene.time.delayedCall(500, ()=>{
                scene.input.enabled = true; 
                
                let nextIndex = currentQuestionIndex + 1; 
                
                if(isReviewing){
                    if (nextIndex === originalQuestionIndexBeforeError) {
                        questionToRepeat = null; 
                        currentQuestionIndex = nextIndex; 
                        showQuestion(currentQuestionIndex);
                    } else if (nextIndex < QUESTIONS.length) {
                        currentQuestionIndex = nextIndex;
                        showQuestion(currentQuestionIndex);
                    } else {
                        showQuestion(QUESTIONS.length);
                    }
                    
                } else {
                    if(nextIndex < QUESTIONS.length){
                        currentQuestionIndex = nextIndex;
                        showQuestion(currentQuestionIndex);
                    } else { 
                        showQuestion(nextIndex); 
                    }
                }
            });

        } else {
            wrongSound.play();
            
            wrongFeedbackDiv.style.backgroundColor='rgba(255,0,0,0.5)';
            errorIndicator.style.opacity = 1;

            scene.time.delayedCall(400, ()=>{
                wrongFeedbackDiv.style.backgroundColor='rgba(255,0,0,0)';
                errorIndicator.style.opacity = 0;
            });
            
            if(currentQuestionIndex > 0){
                
                if(!isReviewing) {
                   questionToRepeat = currentQ;
                   originalQuestionIndexBeforeError = currentQuestionIndex + 1; 
                }

                let prevIndex = currentQuestionIndex - 1;
                currentQuestionIndex = prevIndex;
                
                scene.time.delayedCall(1500, ()=>{
                    scene.input.enabled = true; 
                    showQuestion(currentQuestionIndex); 
                });
                
            } else {
                scene.time.delayedCall(500, ()=>{
                    scene.input.enabled = true; 
                    showQuestion(currentQuestionIndex); 
                });
            }
        }
    }
</script>
</body>
</html>
